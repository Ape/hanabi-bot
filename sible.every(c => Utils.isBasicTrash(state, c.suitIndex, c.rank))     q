[1mdiff --git a/src/basics.js b/src/basics.js[m
[1mindex 694bdfb..146f2b3 100644[m
[1m--- a/src/basics.js[m
[1m+++ b/src/basics.js[m
[36m@@ -27,6 +27,17 @@[m [mfunction onClue(state, action) {[m
 			card.subtract('possible', new_possible);[m
 			card.subtract('inferred', new_possible);[m
 		}[m
[32m+[m
[32m+[m		[32m// Eliminate in own hand (ignore everyone except us)[m
[32m+[m		[32mif (card.possible.length === 1) {[m
[32m+[m			[32mconst ignorePlayerIndexes = [];[m
[32m+[m			[32mfor (let i = 0; i < state.numPlayers; i++) {[m
[32m+[m				[32mif (i !== state.ourPlayerIndex) {[m
[32m+[m					[32mignorePlayerIndexes.push(i);[m
[32m+[m				[32m}[m
[32m+[m			[32m}[m
[32m+[m			[32mcard_elim(state, card.possible[0].suitIndex, card.possible[0].rank, ignorePlayerIndexes);[m
[32m+[m		[32m}[m
 	}[m
 [m
 	state.clue_tokens--;[m
[36m@@ -61,7 +72,7 @@[m [mfunction onDraw(state, action) {[m
 [m
 	// Don't eliminate if we drew the card (since we don't know what it is)[m
 	if (playerIndex !== state.ourPlayerIndex) {[m
[31m-		card_elim(state, suitIndex, rank, playerIndex);[m
[32m+[m		[32mcard_elim(state, suitIndex, rank, [playerIndex]);[m
 	}[m
 [m
 	state.cards_left--;[m
[36m@@ -69,8 +80,12 @@[m [mfunction onDraw(state, action) {[m
 	// suitIndex and rank are -1 if they're your own cards[m
 }[m
 [m
[31m-function card_elim(state, suitIndex, rank) {[m
[32m+[m[32mfunction card_elim(state, suitIndex, rank, ignorePlayerIndexes = []) {[m
 	for (let playerIndex = 0; playerIndex < state.numPlayers; playerIndex++) {[m
[32m+[m		[32mif (ignorePlayerIndexes.includes(playerIndex)) {[m
[32m+[m			[32mcontinue;[m
[32m+[m		[32m}[m
[32m+[m
 		// Skip if already eliminated[m
 		if (!state.all_possible[playerIndex].some(c => c.matches(suitIndex, rank))) {[m
 			continue;[m
[1mdiff --git a/src/basics/Card.js b/src/basics/Card.js[m
[1mindex 0cd5c30..dd62630 100644[m
[1m--- a/src/basics/Card.js[m
[1m+++ b/src/basics/Card.js[m
[36m@@ -6,6 +6,7 @@[m
  *  order: number		the ordinal number of the card[m
  *  possible: [Card]	all possibilities of the card (from positive/negative information)[m
  *  inferred: [Card]	all inferences of the card (from conventions)[m
[32m+[m[32m *  old_inferred: [Card] | undefined		only used when undoing a finesse[m
  *[m
  *  clued, newly_clued, prompted, finessed, chop_moved, reset are boolean flags[m
  *[m
[1mdiff --git a/src/basics/helper.js b/src/basics/helper.js[m
[1mindex c0ec2a4..26ae9b7 100644[m
[1m--- a/src/basics/helper.js[m
[1m+++ b/src/basics/helper.js[m
[36m@@ -51,6 +51,10 @@[m [mfunction bad_touch_possiblities(state, giver, target, prev_found = []) {[m
 				else if (card.inferred.length === 1) {[m
 					({suitIndex, rank} = card.inferred[0]);[m
 					method = 'inference';[m
[32m+[m					[32mif (!card.matches(suitIndex, rank, { infer: true })) {[m
[32m+[m						[32mlogger.warn(`tried to identify ${card.inferred[0].toString()} as bad touch when card's identity is ${card.toString()}`);[m
[32m+[m						[32mcontinue;[m
[32m+[m					[32m}[m
 				}[m
 				else {[m
 					continue;[m
[1mdiff --git a/src/conventions/h-group/action-helper.js b/src/conventions/h-group/action-helper.js[m
[1mindex 6c73a5a..3d8c85e 100644[m
[1m--- a/src/conventions/h-group/action-helper.js[m
[1m+++ b/src/conventions/h-group/action-helper.js[m
[36m@@ -126,9 +126,11 @@[m [mfunction find_urgent_actions(state, play_clues, save_clues, fix_clues) {[m
 		if (save_clues[target] !== undefined || Utils.handLocked(state.hands[target])) {[m
 			// They already have a playable or trash (i.e. early save)[m
 			if (playable_cards.length !== 0 || trash_cards.length !== 0) {[m
[31m-				const { type, value } = save_clues[target];[m
[31m-				urgent_actions[8].push({ tableID: state.tableID, type, target, value });[m
[31m-				continue;[m
[32m+[m				[32mif (save_clues[target] !== undefined) {[m[41m[m
[32m+[m					[32mconst { type, value } = save_clues[target];[m[41m[m
[32m+[m					[32murgent_actions[8].push({ tableID: state.tableID, type, target, value });[m[41m[m
[32m+[m					[32mcontinue;[m[41m[m
[32m+[m				[32m}[m[41m[m
 			}[m
 [m
 			// Try to see if they have a playable card that connects directly through our hand[m
[1mdiff --git a/src/conventions/h-group/clue-finder/clue-finder.js b/src/conventions/h-group/clue-finder/clue-finder.js[m
[1mindex 5920692..ff0adbe 100644[m
[1m--- a/src/conventions/h-group/clue-finder/clue-finder.js[m
[1m+++ b/src/conventions/h-group/clue-finder/clue-finder.js[m
[36m@@ -102,11 +102,15 @@[m [mfunction find_tcm(state, target, saved_cards, trash_card) {[m
 [m
 function find_5cm(state, target, chop) {[m
 	const { suitIndex, rank, order } = chop;[m
[32m+[m	[32mconst clue = { type: ACTION.RANK, value: 5, target };[m
 [m
 	// The card to be chop moved is useful and not clued/finessed/chop moved elsewhere[m
[31m-	if (rank > state.hypo_stacks[suitIndex] && rank <= state.max_ranks[suitIndex] && !Utils.isSaved(state, suitIndex, rank, order)) {[m
[31m-		return { type: ACTION.RANK, value: 5, target };[m
[32m+[m	[32mif (rank > state.hypo_stacks[suitIndex] && rank <= state.max_ranks[suitIndex] &&[m
[32m+[m		[32m!Utils.isSaved(state, suitIndex, rank, order) && clue_safe(state, clue)[m
[32m+[m	[32m) {[m
[32m+[m		[32mreturn clue;[m
 	}[m
[32m+[m
 	return;[m
 }[m
 [m
[1mdiff --git a/src/conventions/h-group/clue-finder/determine-clue.js b/src/conventions/h-group/clue-finder/determine-clue.js[m
[1mindex e79d39e..fdd773c 100644[m
[1m--- a/src/conventions/h-group/clue-finder/determine-clue.js[m
[1m+++ b/src/conventions/h-group/clue-finder/determine-clue.js[m
[36m@@ -27,7 +27,6 @@[m [mfunction determine_clue(state, target, target_card) {[m
 		const result = Object.assign({}, base);[m
 [m
 		const bad_touch_cards = find_bad_touch(state, touch.filter(c => !c.clued));		// Ignore cards that were already clued[m
[31m-		result.bad_touch = bad_touch_cards.length;[m
 		result.focused = determine_focus(hand, touch.map(c => c.order), { beforeClue: true }).focused_card.order === target_card.order;[m
 [m
 		if (!result.focused) {[m
[36m@@ -77,9 +76,9 @@[m [mfunction determine_clue(state, target, target_card) {[m
 [m
 			// Other touched cards can be bad touched/trash or match inference[m
 			if (card.newly_clued) {[m
[31m-				return bad_touch_cards.some(c => c.order === card.order) ||							// Card is bad touched[m
[31m-					card.possible.every(c => Utils.isBasicTrash(state, c.suitIndex, c.rank)) || 	// Card is known trash[m
[31m-					(!card.reset && card.matches_inferences());										// Card matches interpretation[m
[32m+[m				[32mreturn bad_touch_cards.some(c => c.order === card.order) ||								// Card is bad touched[m
[32m+[m					[32mcard.possible.every(c => Utils.isTrash(hypo_state, c.suitIndex, c.rank, card.order)) || 	// Card is known trash[m
[32m+[m					[32m(!card.reset && card.matches_inferences());											// Card matches interpretation[m
 			}[m
 [m
 			if (card.finessed) {[m
[36m@@ -99,14 +98,35 @@[m [mfunction determine_clue(state, target, target_card) {[m
 			/*logger.info(hypo_state.hands[target].map(card => {[m
 				if (card.reset || !card.matches_inferences()) {[m
 					logger.info(`card ${card.toString()} has inferences [${card.inferred.map(c => c.toString()).join(',')}] reset? ${card.reset}`);[m
[32m+[m					[32mlogger.info(Utils.logHand(hypo_state.hands[target]));[m
[32m+[m				[32m}[m
[32m+[m				[32mif (!card.possible.every(c => Utils.isTrash(state, c.suitIndex, c.rank, card.order))) {[m
[32m+[m					[32mlogger.info(`${card.possible.find(c => !Utils.isTrash(state, c.suitIndex, c.rank, card.order))} possibility is not trash`);[m
 				}[m
 				return bad_touch_cards.some(c => c.order === card.order) ||							// Card is bad touched[m
[31m-					card.possible.every(c => Utils.isBasicTrash(state, c.suitIndex, c.rank)) || 	// Card is known trash[m
[32m+[m					[32mcard.possible.every(c => Utils.isTrash(hypo_state, c.suitIndex, c.rank, card.order)) || 	// Card is known trash[m
 					(!card.reset && card.matches_inferences());										// Card matches interpretation[m
 			}));*/[m
 			return { correct: false };[m
 		}[m
 [m
[32m+[m		[32mresult.bad_touch = 0;[m
[32m+[m		[32mresult.trash = 0;[m
[32m+[m		[32mfor (const card of hypo_state.hands[target]) {[m
[32m+[m			[32mif (bad_touch_cards.some(c => c.order === card.order)) {[m
[32m+[m				[32m// Known trash[m
[32m+[m				[32mif (card.possible.every(p => Utils.isTrash(hypo_state, p.suitIndex, p.rank, card.order))) {[m
[32m+[m					[32mresult.trash++;[m
[32m+[m				[32m}[m
[32m+[m				[32melse {[m
[32m+[m					[32mlogger.info(`${card.toString()} is bad touch`);[m
[32m+[m					[32mlogger.info(card.possible.map(c => c.toString()));[m
[32m+[m					[32mlogger.info(card.possible.find(p => !Utils.isTrash(hypo_state, p.suitIndex, p.rank, card.order)).toString());[m
[32m+[m					[32mresult.bad_touch++;[m
[32m+[m				[32m}[m
[32m+[m			[32m}[m
[32m+[m		[32m}[m
[32m+[m
 		// Re-simulate clue, but from our perspective so we can count the playable cards and finesses correctly[m
 		hypo_state = Utils.objClone(state);[m
 [m
[36m@@ -119,8 +139,8 @@[m [mfunction determine_clue(state, target, target_card) {[m
 		result.playables = [];[m
 [m
 		// Count the number of finesses and newly known playable cards[m
[31m-		logger.info(hypo_state.hypo_stacks);[m
[31m-		logger.info(state.hypo_stacks);[m
[32m+[m		[32mlogger.debug(`hypo stacks before clue: ${hypo_state.hypo_stacks}`);[m
[32m+[m		[32mlogger.debug(`hypo stacks after clue: ${state.hypo_stacks}`);[m
 		for (let suitIndex = 0; suitIndex < state.suits.length; suitIndex++) {[m
 			for (let rank = state.hypo_stacks[suitIndex] + 1; rank <= hypo_state.hypo_stacks[suitIndex]; rank++) {[m
 				// Find the card[m
[36m@@ -156,10 +176,11 @@[m [mfunction determine_clue(state, target, target_card) {[m
 	});[m
 [m
 	const logResult = (result) => {[m
[31m-		const { clue, bad_touch, interpret, elim, new_touched, finesses, playables } = result;[m
[32m+[m		[32mconst { clue, bad_touch, trash, interpret, elim, new_touched, finesses, playables } = result;[m
 		return {[m
 			clue,[m
 			bad_touch,[m
[32m+[m			[32mtrash,[m
 			interpret: interpret?.map(c => c.toString()),[m
 			elim,[m
 			new_touched,[m
[1mdiff --git a/src/conventions/h-group/clue-finder/fix-clues.js b/src/conventions/h-group/clue-finder/fix-clues.js[m
[1mindex d81861b..a5e077f 100644[m
[1m--- a/src/conventions/h-group/clue-finder/fix-clues.js[m
[1m+++ b/src/conventions/h-group/clue-finder/fix-clues.js[m
[36m@@ -16,8 +16,8 @@[m [mfunction find_fix_clues(state, play_clues, save_clues) {[m
 		const hand = state.hands[target];[m
 [m
 		for (const card of hand) {[m
[31m-			// Card known, doesn't need fix[m
[31m-			if (card.possible.length === 1) {[m
[32m+[m			[32m// Card known (or known trash), doesn't need fix[m[41m[m
[32m+[m			[32mif (card.possible.length === 1 || card.possible.every(c => Utils.isBasicTrash(state, c.suitIndex, c.rank))) {[m[41m[m
 				continue;[m
 			}[m
 [m
[1mdiff --git a/src/conventions/h-group/interpret-clue.js b/src/conventions/h-group/interpret-clue.js[m
[1mindex 6702ac6..926057f 100644[m
[1m--- a/src/conventions/h-group/interpret-clue.js[m
[1m+++ b/src/conventions/h-group/interpret-clue.js[m
[36m@@ -13,7 +13,7 @@[m [mfunction stalling_situation(state, action) {[m
 [m
 	let severity = 0;[m
 [m
[31m-	if (state.clue_tokens === 7) {[m
[32m+[m	[32mif (state.clue_tokens === 7 && state.turn_count !== 0) {[m[41m[m
 		severity = 4;[m
 	}[m
 	else if (Utils.handLocked(state.hands[giver])) {[m
[36m@@ -102,6 +102,10 @@[m [mfunction interpret_clue(state, action, options = {}) {[m
 	const { clue, giver, list, target, mistake = false } = action;[m
 	const { focused_card, chop } = determine_focus(state.hands[target], list);[m
 [m
[32m+[m	[32mif (focused_card.inferred.length === 0) {[m[41m[m
[32m+[m		[32mfocused_card.inferred = Utils.objClone(focused_card.possible);[m[41m[m
[32m+[m	[32m}[m[41m[m
[32m+[m[41m[m
 	let fix = false;[m
 [m
 	// Touched cards should also obey good touch principle[m
[36m@@ -144,7 +148,7 @@[m [mfunction interpret_clue(state, action, options = {}) {[m
 		return;[m
 	}[m
 [m
[31m-	if (!options.ignoreStall && state.turn_count !== 0 && stalling_situation(state, action)) {[m
[32m+[m	[32mif (!options.ignoreStall && stalling_situation(state, action)) {[m[41m[m
 		return;[m
 	}[m
 [m
[36m@@ -251,6 +255,8 @@[m [mfunction interpret_clue(state, action, options = {}) {[m
 					logger.info(`connecting on ${card.toString()} order ${card.order} type ${type}`);[m
 					if (type === 'finesse') {[m
 						card.finessed = true;[m
[32m+[m						[32m// Save the old inferences in case this is not actually a finesse[m[41m[m
[32m+[m						[32mcard.old_inferred = Utils.objClone(card.inferred);[m[41m[m
 						card.inferred = [new Card(suitIndex, next_rank)];[m
 					}[m
 					next_rank++;[m
[1mdiff --git a/src/conventions/h-group/interpret-discard.js b/src/conventions/h-group/interpret-discard.js[m
[1mindex 1a90410..a152530 100644[m
[1m--- a/src/conventions/h-group/interpret-discard.js[m
[1m+++ b/src/conventions/h-group/interpret-discard.js[m
[36m@@ -37,7 +37,7 @@[m [mfunction apply_unknown_sarcastic(state, sarcastic, playerIndex, suitIndex, rank)[m
 }[m
 [m
 function interpret_discard(state, action, card) {[m
[31m-	const { order, playerIndex, rank, suitIndex } = action;[m
[32m+[m	[32mconst { order, playerIndex, rank, suitIndex, failed } = action;[m[41m[m
 [m
 	const trash = find_known_trash(state, playerIndex);[m
 	// Early game and discard wasn't known trash or misplay, so end early game[m
[36m@@ -45,8 +45,8 @@[m [mfunction interpret_discard(state, action, card) {[m
 		state.early_game = false;[m
 	}[m
 [m
[31m-	// If the card doesn't match any of our inferences (and is not trash), rewind to the reasoning and adjust[m
[31m-	if (!Utils.isTrash(state, card.suitIndex, card.rank, card.order) && !card.rewinded && !card.matches_inferences()) {[m
[32m+[m	[32m// If bombed or the card doesn't match any of our inferences (and is not trash), rewind to the reasoning and adjust[m[41m[m
[32m+[m	[32mif (!card.rewinded && (failed || (!card.matches_inferences() && !Utils.isTrash(state, card.suitIndex, card.rank, card.order)))) {[m[41m[m
 		logger.info('all inferences', card.inferred.map(c => c.toString()));[m
 		state.rewind(state, card.reasoning.pop(), playerIndex, order, suitIndex, rank, true);[m
 		return;[m
[36m@@ -57,7 +57,7 @@[m [mfunction interpret_discard(state, action, card) {[m
 		const duplicates = Utils.visibleFind(state, playerIndex, suitIndex, rank);[m
 [m
 		// Card was bombed[m
[31m-		if (action.failed) {[m
[32m+[m		[32mif (failed) {[m[41m[m
 			undo_hypo_stacks(state, playerIndex, suitIndex, rank);[m
 		}[m
 		else {[m
[1mdiff --git a/src/conventions/h-group/interpret-helper.js b/src/conventions/h-group/interpret-helper.js[m
[1mindex 9be64ef..976ee3d 100644[m
[1m--- a/src/conventions/h-group/interpret-helper.js[m
[1m+++ b/src/conventions/h-group/interpret-helper.js[m
[36m@@ -129,7 +129,10 @@[m [mfunction find_focus_possible(state, giver, target, clue, chop, ignoreCard) {[m
 		}[m
 	}[m
 [m
[31m-	return focus_possible;[m
[32m+[m	[32m// Remove earlier duplicates (since save overrides play)[m[41m[m
[32m+[m	[32mreturn focus_possible.filter((p1, index1) => {[m[41m[m
[32m+[m		[32mreturn !focus_possible.some((p2, index2) => p1.suitIndex === p2.suitIndex && p1.rank === p2.rank && index1 < index2);[m[41m[m
[32m+[m	[32m});[m[41m[m
 }[m
 [m
 function find_connecting(state, giver, target, suitIndex, rank, ignoreOrders = []) {[m
[1mdiff --git a/src/conventions/h-group/update-turn.js b/src/conventions/h-group/update-turn.js[m
[1mindex 8a01932..0d513f6 100644[m
[1m--- a/src/conventions/h-group/update-turn.js[m
[1m+++ b/src/conventions/h-group/update-turn.js[m
[36m@@ -8,7 +8,12 @@[m [mfunction remove_finesse(state, waiting_index) {[m
 	// Remove remaining finesses[m
 	for (const { type, reacting, card } of connections) {[m
 		if (type === 'finesse') {[m
[31m-			Utils.findOrder(state.hands[reacting], card.order).finessed = false;[m
[32m+[m			[32mconst finessed_card = Utils.findOrder(state.hands[reacting], card.order);[m[41m[m
[32m+[m			[32mfinessed_card.finessed = false;[m[41m[m
[32m+[m[41m[m
[32m+[m			[32m// Restore old inferences[m[41m[m
[32m+[m			[32mfinessed_card.inferred = finessed_card.old_inferred;[m[41m[m
[32m+[m			[32mfinessed_card.old_inferred = undefined;[m[41m[m
 		}[m
 	}[m
 [m
